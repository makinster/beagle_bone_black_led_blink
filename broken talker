@ PROGRAM TO INTERFACE RC SYSTEMS 8660 SPEECH SYNTHESIS BOARD

@ WITH BEAGLEBONE BLACK USING RS-232C COM 2 PORT ON AN INTERRPT BASIS

@ DRAFT STARTED BY KELLY MAKINSTER, 2019                                                                                                               
                                                                                                                                                       
.text                                                                                                                                                  
.global _start  
.global INT_DIRECTOR                                                                                                                                       
_start:   
		@ Initialize Stack
        LDR R13,=STACK1				@ Point to base of stack for SVC mode
        ADD R13, R13, #0x1000		@ Point to the top of the stack   
        CPS #0x12					@ Switch to IRQ mode  
       	LDR R13,=STACK2				@ Point to base of stack for IRQ mode
       	ADD R13, R13, #0x1000		@ Point to the top of the stack   
       	CPS #0x13					@ Switch to SVC mode
       	
		@ WAKE UP GPIO01 & GPIO02                                                                                                                                               
		MOV R0,#0x02				@ Value to wake up GPIO_1 Clk
		LDR R1,=0x44E000AC			@ CM_WKUP_GPIO01_CLKCTR Register
		STR R0, [R1]				@ write to register
		LDR R1,=0x44E000B0			@ CM_WKUP_GPIO01_CLKCTR Register
		STR R0, [R1]				@ write to register
		
		@ Clear Outputs 21-24
		LDR R0,=0x4804C000			@ Base address for GPIO01 registers
		LDR R1,=0x01E00000			@ Clears GPIO 21-24
		STR R1,[R0, #0x190]			@ Write to GPIO01_CLEARDATAOUT
		
		@ Program Outputs 21-24
		ADD R1, R0,#0x134			@ Offset for GPIO01_OE
		LDR R6,[R1]					@ (Read) current GPIO01_OE register
		LDR R7,=0xFE1FFFFF			@ Word to enable pins 21-24
		AND R6,R7,R6				@ Clear bits 21-24 (modify)
		STR R6,[R1]					@ (write) to GPIO01_OE
		
		@ Program falling edge on GPIO02_1 (button)
		LDR R0,=0x481AC000			@ Base address for GPIO02 registers
		MOV R1, #0x02				@ Load value for bit 1 (button)
		LDR R2, [R0, #0x14C]		@ Read GPIO01_FALLINGDETECT register
		ORR R2, R1, R2				@ Modify (set bit 30)
		STR R2, [R0, #0x14C]		@ Write back
		STR R1, [R0, #0x34]			@ Write back
		
		@Initialize INTC
		LDR R1,=0x48200000			@ Base address of INTC
		MOV R2, #0x2				@ Value to reset INTC
		STR R2, [R1, #0x10]			@ Write to INTC Config register
		MOV R2, #0x10				@ Value to unmask INTC INT 68, Timer2 interrupt
		STR R2, [R1, #0xC8]			@ Write to INTC_MIR_CLEAR2 register
		LDR R2,=0x4001				@ Value to unmask INTC INT 32 For button press (bit 1) and INT 46 UART5
		STR R2, [R1, #0xA8]			@ Write to INTC_MIR_CLEAR1 register

		
		@Program UART5 pins
		LDR R1,=0x44E10000			@ Base address for Control Module
		MOV R2, #6				@ Word for mode 6
		STR R2, [R1, #0x8D8]		@ Write to lcd data 14 - CTS
		STR R2, [R1, #0x8DC]		@ Write to lcd data 15 - RTS
		MOV R2, #0x4				@ Word for mode 4 and input enabled
		STR R2, [R1, #0x8C0]		@ Write to lcd data 8 - TxD
		STR R2, [R1, #0x8C4]		@ Write to lcd data 9 - RxD
		@lcd pin 14	- 0x44E108D8	mode 6: 0x101110
		@lcd pin 15	- 0x44E108DC	mode 6: 0x101110
		@lcd pin 8	- 0x44E108C0	mode 4: 0x101100
		@lcd pin 9	- 0x44E108C4	mode 4: 0x101100
	
	
		@Turn on UART5 clock
		LDR R1,=0x44E00038			@ Base address for Control Module	
		MOV R2,#0x02				@ Value to reset clock
		STR R2, [R1]				@ write to UART5_CLKCTRL
		
		@Initialize UART5
		
		@switch to configuration mode A
		LDR R1,=0x481AA000			@ Base address for UART5
		MOV R2,#0x83				@ Word to switch to configuration mode A
		STR R2, [R1, #0x0C]			@ Write to LCR

		@Set Baud Rate
		MOV R2,#0x4E				@ Value to set DLL clock
		STR R2, [R1]				@ Write to DLL
		MOV R2,#0x00				@ Value to set DLH clock
		STR R2, [R1, #0x04]			@ Write to DLH
		@set DLH - DLL dividor to 16
		STR R2, [R1, #0x20]			@ Write 0 to to MDR1 to reset

		@Switch back to configuration mode
		MOV R2,#0x03				@ Word to switch to operational mode (LCR[7] = 0)
		STR R2, [R1, #0x0C]			@ Write to LCR

		@enable UART interrupts
		MOV R2,#0xA					@ Word to enable interupts 1010
		STR R2, [R1, #0x04]			@ Write to IER_UART
		@Disable RX_FIFO, TX_FIFO & FIFO_EN
		@MOV R2,#0x3					@ Word to disable RX_FIFO, TX_FIFO & FIFO_EN
		MOV R2,#0x00
		STR R2, [R1, #0x8]			@ Write to FCR
		
		@Turn on timer2
		MOV R2, #0x2				@ Value to Enable Timer2
		LDR R1,=0x44E00080			@ Address of CM_PER_TIMER2_CLKCTR
		STR R2, [R1]				@ Turn on
		@LDR R1,=0x44E00508			@ Address of PRCMCLKSEL_TIMER2 Register
		@STR R2, [R1]				@ Select 32 KHz clk for timer2
		
		@Initialize timer2 registers with count and overflow interrupt generation
		LDR R1,=0x48040000			@ Base address for timer2 registers
		MOV R2, #0x1				@ Value to reset timer2
		STR R2, [R1, #0x10]			@ Write to Timer2 CFG register
		@MOV R2, #0x2				@ Value to enable overflow interrupt
		@STR R2, [R1, #0X2C]			@ Write to timer2 IRQENABLE_SET
		LDR R2,=0xFFFF8300			@ Count value for 1 second
		STR R2, [R1, #0x40]			@ Timer2 TLDR load register (reload value)
		STR R2, [R1, #0x3C]			@ Write to Timer2 TCRR count register
		
		MOV R2, #0x3				@ Value to enable auto-reload
		STR R2, [R1, #0X38]			@ Write to timer2 IRQENABLE_SET
		MOV R2, #0x2				@ Value to enable overflow interrupt
		STR R2, [R1, #0X2C]			@ Write to timer2 IRQENABLE_SET
		
		
		LDR R0,=0x481AC02C			@ GPIO2_GPIO_IRQSTATUS_0		
		MOV R1,#0x02				@ Word to turn off GPIO2_1 IRQ request
		STR R1, [R0]				@ Turn off
		@ Turn off NEWIRQA bit in INTC_CONTROL register
		LDR R0,=0x48200048			@ Address of INTC_CONTROL register
		MOV R1, #01					@ Value to clear bit 0
		STR R1,[R0]					@ Write to INTC_CONTROL register
		
		@Make sure processor IRQ enabled in CPSR
		MRS R3, CPSR				@ Copy CPSR to R3
		BIC R3, #0x80				@ Clear bit 7
		MSR CPSR_c, R3				@ Write back to CPSR		

LOOP:	NOP
		B LOOP						@ Go back to light procedure
			
INT_DIRECTOR:
		STMFD SP!, {R0-R5, LR}		@ Push Registers onto stack

		@see if interupt came from UART
		LDR R0,=0x482000B8			@ Load address of INTC-PENDING_IRQ1 register
		LDR R1, [R0]				@ Read INTC-PENDING_IRQ1 register
		TST R1, #0x1				@ Test Bit 1		
		BNE BTN_SVC					@ Go to BTN_SVC procedure
		TST R1, #0x4000				@ Test Bit 14 (int 46)	
		BNE TALKER_SVC				@ talker interrupt occured
		B GOBCK		
GOBCK:	
		LDMFD SP!, {R0-R5, LR}		@ Restore registers
		SUBS PC, LR, #4				@ Pass execution on to wait loop
			
TALKER_SVC:
		LDR R1,=0x481AA018			@ Base address for UART5 modem status
		LDRB R3, [R1]				@ Read
		TST R3, #0x10				@ Test Bit 4 - CTS
		BEQ PASS_ON_TALKER			@ CTS not set
		LDR R1,=0x481AA014			@ Base address for UART5 modem status
		LDRB R3, [R1]				@ Read
		TST R3, #0x20				@ Test Bit 5 - THR
		BNE SEND					@ Go to send procedure
		B GOBCK						@ THR not set
								
SEND:	
		@ enable interrupts
		LDR R1,=0x481AA000			@ Address for IER_UART
		MOV R2,#0xA					@ Word to enable interupts 1010
		STR R2, [R1, #0x04]			@ Write to IER_UART
		
			
		LDR	R0, =CHAR_PTR			@ SEND CHARACTER, R0 = ADDRESS OF POINTER STORE		
		LDR	R0, =CHAR_PTR			@ SEND CHARACTER, R0 = ADDRESS OF POINTER STORE
		@LDR	R1, [R0]				@ R1 = ADDRESS OF DESIRED CHARACTER IN TEXT STRING
		LDRB	R3, [R0]			@ READ CHAR TO send from string and increment pointer
		@STR	R3, [R0]				@ PUT INCREMENTED ADDRESS BACK IN CHAR_PTR LOCATION
		CMP R3, #0xD				@ Check for 0xD character
		BEQ TCHK					
		
		@Reset clock
		LDR R4,=0x48040000			@ Base address for timer2 registers
		LDR R5,=0xFFFF8300			@ Count value for 1 second
		STR R5, [R4, #0x3C]			@ Write to Timer2 TCRR count register
		
		LDR	R0, =0x481AA000			@ address of TRANSMIT BUFFER
		STRB	R3, [R0]			@ write back
		
		LDR	R2,=CHAR_COUNT
		LDR	R2,=CHAR_COUNT			@ R2 = ADDRESS OF COUNT STORE LOCATION
		LDRB	R3, [R2]				@ GET CURRENT CHARACTER COUNT VALUE
		SUBS	R3, R3, #1			@ DECREMENT CHARACTER COUNTER BY 1	
		STRB	R3, [R2]				@ STORE CHARACTER VALUE COUNTER BACK IN MEMORY
		CMP R3, #0x0				@ CHAR_COUNT is at 30 (10 was just said)
		BNE	GOBCK					@ still characters remaining
									@ else
		LDR	R3, =MESSAGE
		LDR	R3, =MESSAGE			@ DONE, RELOAD. GET ADDRESS OF START OF STRING
		STR R3, [R0]				@ WRITE IN CHAR POINTER STORE LOCATION IN MEMORY
		MOV R3, #MESSAGE_LEN		@ LOAD ORIGINAL NUMBER OF CHAR IN STRING AGAIN
		STR R3, [R2]				@ WRITE BACK TO MEMORY FOR NEXT MESSAGE SEND
		
		LDR R0, =0x481AA004			@ LOAD ADDRESS OF MODEM CONTROL REGISTER (MCR)
		LDRB R1, [R0]				@ READ CURRENT VALUE OF REGISTER
		BIC R1, R1, #0x02			@ CLEAR BIT 2 TO DISABLE UART INTERRUPTS
		STRB R1, [R0]				@ WRITE BYTE BACK TO ICMR REGISTER
		B GOBCK		
		
PASS_ON_TALKER:
		LDR R1,=0x481AA014			@ Base address for LSR_UART
		LDRB R2, [R0]				@ Read (won't reset)
		TST R2, #0x20				@ Test Bit 5 - THR
		BEQ GOBCK					@ Exit - CTS and THR are not asserted
		LDR R1,=0x481AA004			@ Base address for UART5
		MOV R2,#0x08				@ Word to enable interupts 1010
		STRB R2, [R1]				@ Write to IER_UART
		B GOBCK

TCHK:	@ turn off interrupt and branch to counter procedure
		@ turn off interupt request
		LDR R1,=0x482000D8			@ INTC_PENDING_IRQ2 REGISTER
		LDR R0,[R1]					@ Read value
		TST R0, #0X4				@ Check bit 2
		BEQ GOBCK
		
		LDR R1,=0x48040028			@ Address of IRQSTATUS register
		LDR R0,[R1]					@ Read value
		TST R0, #0X2				@ Check bit 1
		BEQ GOBCK					@ Unrelated interrupt
		
		LDR R1,=0x482000D8			@ INTC_PENDING_IRQ2 REGISTER
		LDR R0,[R1]					@ Read value
		TST R0, #0X1				@ Check bit 1
		BEQ GOBCK
		
		LDR R1,=0x48040028			@ Address if TIMER2 IRQSTATUS register
		MOV R2, #0x2				@ Value to reset TIMER2 overflow IRQ request
		STR R2, [R1]				@ Write
		LDR R1,=0x48200048			@ Address of INTC_CONTROL
		MOV R2, #0x1				@ Value to reset TIMER2 overflow IRQ request
		STR R2, [R1]				@ Write
		MOV R3, #0xD				
		LDR	R0, =0x481AA000			@ address of TRANSMIT BUFFER
		STRB	R3, [R0]			@ write back
		LDR	R0, =CHAR_PTR
		LDR	R0, =CHAR_PTR			@ SEND CHARACTER, R0 = ADDRESS OF POINTER STORE
		LDR	R1, [R0]				@ R1 = ADDRESS OF DESIRED CHARACTER IN TEXT STRING
		ADD R1, R1, #0x1			@ Increment
		@LDRB	R3, [R1], #1		@ READ CHAR TO send from string and increment pointer
		STR	R1, [R0]				@ PUT INCREMENTED ADDRESS BACK IN CHAR_PTR LOCATION
		B GOBCK
		
		
BTN_SVC:
		LDR R0,=0x481AC02C			@ GPIO2_GPIO_IRQSTATUS_0
		LDR R1, [R0]				@ Read Value
		TST R1,#0x02				@ Test bit 1 for INT32
		BEQ GOBCK					@ Interrupt didnt come from button
		
		MOV R1,#0x02				@ Word to turn off GPIO2_1 IRQ request
		STR R1, [R0]				@ Turn off
		@ Turn off NEWIRQA bit in INTC_CONTROL register
		LDR R0,=0x48200048			@ Address of INTC_CONTROL register
		MOV R1, #01					@ Value to clear bit 0
		STR R1,[R0]					@ Write to INTC_CONTROL register
		
		@Enable THR and MSR interrupt
		LDR R1,=0x481AA000			@ Address for IER_UART
		MOV R2,#0xA					@ Word to enable interupts 1010
		STR R2, [R1, #0x04]			@ Write to IER_UART
		
		@Enable Timer interrupt
		@ Start Timer2
		LDR R1,=0x48040000			@ Base address for timer2 registers
		MOV R2, #0x3				@ Value to Start timer2
		STR R2, [R1,#0x38]			@ Write to  TIMER3 CTRL register
		
		@ Turn off all LEDs
		LDR R0,=0x4804C190			@ Base address for GPIO01 registers
		LDR R2,=0x01E00000			@ Clears GPIO 21-24
		STR R2,[R0]					@ Write to GPIO01_CLEARDATAOUT
		B GOBCK
		
		
.data
.align 2
MESSAGE:
	.ascii "10"
	.byte 0xD
	.ascii "9"
	.byte 0xD
	.ascii "8"
	.byte 0xD
	.ascii "7"
	.byte 0xD
	.ascii "6"
	.byte 0xD
	.ascii "5"
	.byte 0xD
	.ascii "4"
	.byte 0xD
	.ascii "3"
	.byte 0xD
	.ascii "2"
	.byte 0xD
	.ascii "1"
	.byte 0xD
	.ascii "blast off"
	.byte 0xD
CHAR_PTR:	.word MESSAGE
CHAR_COUNT:	.word 33
.EQU     	 MESSAGE_LEN,33
	
STACK1:		.rept 1024
			.word 0x0000
			.endr           
STACK2:		.rept 1024
			.word 0x0000
			.endr                                                                                                                                                                                                                                                                          
.END                                                                                                                                                  
